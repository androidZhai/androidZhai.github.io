---
layout: post
title: 基础知识点复习
---

java基础知识点

##### 有时候面试感觉对于基础知识懵懵懂懂，究其原因还是理解不到位，所以写下这篇博客，时常看看加深理解。

### 1.面向对象与面向过程的区别

面向过程是分析出解决问题所需要的步骤，然后用函数把这些步骤一步步实现，使用的时候依次调用。<br/> 
面向对象是把事务分解成各个对象，建立对象的目的不是为了完成某一个步骤，而是为了描述某个对象在整个事务中的行为。

### 2.面向对象的三大特性

封装——也称信息隐藏，尽可能的隐藏内部细节，只留一些对外接口与外界发生联系。<br/> 
继承——一个继承另一个类，继承的为子类，被继承的为父类。实现代码的复用。若要让某个类继承，父类需适当开发访问权限，要遵循替换原则和开闭原则。另外子类可以有自己特有的属性和方法来实现扩展，也可以重写父类的方法。<br/> 
多态——是以封装和继承为基础的。相同的事物，调用其相同的方法，参数也相同时，但表现的行为不同。子类以父类的身份出现，但是做事情时还说以自己的方法实现。比如一个品酒大师，看到桌上有三杯酒，对外都是父类酒这个对象，但是喝了才发现依次是剑南春、五粮液、天之蓝。
Wine a = new JNC();也就是所谓的向上转型。（向上转型是安全的，但无法调用子类的方法；向下转型需要强制转换，是不安全的）

### 3.函数的重载

几个功能类似的函数拥有相同的名称，而参数不同或参数类型不同。

### 4.对象的向上转型和向下转型

子类引用的对象转换为父类类型称为向上转型。<br/>
父类引用的对象转换为子类类型称为向下转型。<br/>
父类：人；子类：男人和女人。<br>
向上转型：Person p = new Man;<br>
向下转型：Man man = (Man) new Person();<br>

### 5.static的作用

用来修饰成员变量和成员方法，也可以形成静态代码块。<br/>
被static修饰的成员变量和成员方法独立于该类的任何对象，不依赖于特定的实例，被类所有实例共享。<br/>
被static修饰的代码块表示静态代码块，当java虚拟机(JVM)加载类时，就会执行该代码（用处非常大）。<br/>
一般需要实现以下两个功能时使用静态变量：<br/>
在对象之间共享值时<br/>
方便访问变量时<br/>
静态方法为了方便方法的调用，如Java API中Math类中所有的方法都是静态的，而一般类内部的staic方法也是方便其他类对该方法的调用。

### 6.final关键字的作用

final放在类前面<br/>
&#160; &#160; &#160; &#160;如果某个类在定义时，前面有修饰词final，则该类不能被继承。如：String、Interger。
final放在属性前面<br/>
&#160; &#160; &#160; &#160;属性声明时，如果前面有修饰词final，则该属性不能被更改，即常量.<br/>
fianl放在方法前面<br/>
&#160; &#160; &#160; &#160;如果某个方法在定义时，前面有修饰词final，该方法可以被调用，不能重写。<br/>
fianl修饰的优点：<br/>
1.提高了性能。JVM和java应用都会缓存final变量。<br/>
2.fianl变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。<br/>
3.使用final关键字，JVM会对变量、方法及类进行优化。<br/>

### 7.抽象类和接口的区别

1.抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；<br>
2.抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br/>
3.接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；<br/>
4.一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br/>
抽象类是对一种事物的抽象，即对类的抽象；而接口是对行为的抽象。<br/>
&#160; &#160; &#160; &#160;网上有个广泛流传的例子：门和警报的例子：门都有open()和close()两个动作，此时抽象类和接口都可以定义这个抽象概念。<br/>
&#160; &#160; &#160; &#160;但是如果我们需要门具有报警alarm()的功能，该如何实现？都放在抽象类中有什么弊端，都放在接口有什么弊端？<br/>
&#160; &#160; &#160; &#160;从这里可以看出open和close是门的本身固有的特性，但是不是所有的门都具有报警alarm功能，属于延伸行为。最好的办法单独将报警设计为一个接口，包含alarm行为，Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。

### 8.工厂设计模式

[查看具体文章](http://blog.csdn.net/hguisu/article/details/7505909)<br/>
工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。<br/>
工厂模式可以分为三类：<br/>
1.简单工厂模式<br/>
2.工厂方法模式<br/>
3.抽象工厂模式<br/>
区别：<br/>
工厂方法模式：<br/>
一个抽象产品类，可以派生出多个具体产品类。<br/>
一个抽象工厂类，可以派生出多个具体工厂类。<br/>
每个具体工厂类只能创建一个具体产品类的实例。<br/>
抽象工厂模式：
多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。<br/>
一个抽象工厂类，可以派生出多个具体工厂类。<br/>
每个具体工厂类可以创建多个具体产品类的实例。<br/> 
区别：<br/>
工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。<br/>
工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。<br/>
两者皆可。<br/>
在下面情况下你可以考虑使用工厂方法模式：<br/>
1)当客户程序不需要知道使用对象的创建过程。<br/>
2)客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象。<br/>
在下面情况下你可以考虑使用抽象工厂模式：<br/>
1)系统中有多个产品族，而系统一次只可能消费其中一族产品。<br/>
2)客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象。<br/>

### 9.进程和线程的概念

[查看具体文章](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)<br/>
有一个很好的类比：<br/>
CPU是一个工厂，但是电力有限，每次只能有一个车间（进程）在工作，一个车间有很多工人（线程）协同完成一个任务。一个进程可以包括多个线程。车间的空间（内存）是工人们共享的。但是每间房间大小不同，有的房间同时只能容纳一个人比如厕所，这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。一个防止他人进入的方法就是上锁（互斥锁），先到的人锁上门，后到的人看到上锁后就在门口排队。还有的房间可以同时容纳n个人，比如厨房。如果人数大于n，多出来的人只能在外面等着，好比某些内存区域，只能供给固定数目的线程使用。这时的解决办法就是在门口挂n把钥匙。进去的人就取一把钥匙，出来再把钥匙挂回原处（信号量），用来保证多个线程不会互相冲突。<br/>
操作系统的设计，因此可以归结为三点：<br/>
1.以多进程形式，允许多个任务同时进行；
2.以多线程形式，允许单个任务分成不同的部分进行；
3.提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。