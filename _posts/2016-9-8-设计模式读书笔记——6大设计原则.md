---
layout: post
title: 设计模式读书笔记——6大设计原则
---

### 前言

设计模式是什么？是一套理论，由软件界的先辈们总结出的一套可以反复使用的经验，<u>它可以提高代码的可重用性，增强系统的可维护性，以及解决一系列的复杂问题。</u><br/>
6大设计原则仅仅是一系列“口号”，真正付诸实施还需要有详尽的指导方法，于是23种设计模式出现了。<br/>
设计模式不是工具、它是软件开发的哲学，它能指导你如何去设计一个优秀的架构、编写一段健壮的代码、解决一个复杂的需求。<br/>
如果你通晓了这23种设计模式就不同了，你可以站在一个更高的层次去赏析程序代码、软件设计、架构，完成从代码工人到架构师的蜕变。（注意是“通晓”，而不是我知道，我了解，通晓需要工作上的积累。）<br/>

### 1.单一职责原则
简称SRP，是个备受争议的原则。<br/>

1.1 用了一个用户管理的例子来说明单一职责原则的定义是：<u>应该有且仅有一个原因引起类的变更。</u> <br/>
&#160; &#160; &#160; &#160;用户管理中的UserInfo接口应该拆成两个接口（IUserBO和IUserBiz），各自表示为业务对象和业务逻辑。

2.2 通过电话的例子说明<u>单一职责的好处：类的复杂性降低，可读性高，可维护性提高，变更引起的风险降低，难点：职责的划分</u>。<br/>
&#160; &#160; &#160; &#160;电话IPhone接口有三个方法：拨号，通话，挂电话。是只有一个原因引起变化吗？不是，协议接通的变化和数据传送的变化都会引起这个接口的变化。这边应该有两个职责：协议管理和数据传送。

3.3 <u>使用范围：接口、类、方法。</u><br/>
对于接口设计一定要做到单一，但是对于实现类就需要多方面考虑了，不能生搬硬套，引起类的剧增，把简单的问题复杂化。对于方法，使用单一原则，一个方法一个职责，开发维护起来更方便。（这里举了个例子说明中国文化有很多混合的产物：筷子就有两个职责：既做刀，又做叉）

### 2.里氏替换原则
简称LSP

2.1 定义：<u>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误和异常，使用者可能根本不需要知道是父类还是子类。但是反过来不行。</u>

2.2 规则<br/>
&#160;&#160;&#160;&#160;<u>1.子类必须完全实现父类的方法（或重写父类的方法），否则就不能继承父类。</u>这里举例：在FPS类游戏中，抽象类枪有射击杀人的方法，但是玩具枪不具备真枪杀人的业务，所以不能继承这个类。<br/>
&#160;&#160;&#160;&#160;<u>2.子类可以有自己的个性。</u>
（狙击枪）(new 步枪（）);//会报java.lang.ClassCastException的异常向下转型不安全，父类可能不具有子类特有属性和方法。<br/>
&#160;&#160;&#160;&#160;<u>3.复写或实现父类的方法时输入参数可以被放大。</u>如果父类的输入参数类型宽于子类的输入参数类型，那么父类出现的地方，子类未必能胜任。就有可能进入子类自己的方法范畴。<br>
&#160;&#160;&#160;&#160;<u>4.复写或实现父类的方法时输出结果可以被缩小。</u>

2.3 最佳实践<br/>
&#160;&#160;&#160;&#160;尽量避免子类的“个性”，一旦子类有“个性”，把子类当做父类使用，子类的“个性”被抹杀——委屈了点；把子类单独作为一个业务来使用，则会让代码间的耦合关系变得扑朔迷离——缺乏类替换的标准。

### 3.依赖倒置原则
3.1 定义：<u>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</u> 

3.2 规则<br/>
&#160;&#160;&#160;&#160;不使用依赖倒置原则就会加重类间的耦合性，降低系统的稳定性，增加并行开发的风险，降低代码的可读性和可维护性。通过一个司机开奔驰车后来又增加宝马车的例子说明。

3.3 依赖的三种写法<br/>
&#160;&#160;&#160;&#160;依赖是可以传递的，A对象依赖B对象，B又依赖C，C又依赖D。<br/>
&#160;&#160;&#160;&#160;1.构造函数传递依赖对象<br/>
&#160;&#160;&#160;&#160;2.Setter方法传递依赖对象<br/>
&#160;&#160;&#160;&#160;3.接口声明依赖对象<br/>

3.4 最佳实践（6大原则中最难实现的）
&#160;&#160;&#160;&#160;原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。
只要遵循以下几个规则：<br/>
&#160;&#160;&#160;&#160;每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备。<br/>
&#160;&#160;&#160;&#160;变量的表面类型尽量是接口或抽象类。<br/>
&#160;&#160;&#160;&#160;任何类都不应该从具体类派生。<br/>
&#160;&#160;&#160;&#160;尽量不要复写基类的方法。<br/>
&#160;&#160;&#160;&#160;结合里氏替换原则使用。<br/>

在现实世界中确实存在着必须依赖细节的事物，比如法律：杀人偿命。好人杀了坏人是不需要偿命的。所以实际的项目中需要审时度势，不能为了实现原则而放弃了一个项目的终极目标：投产上线和盈利。

### 4.接口隔离原则
4.1 定义：<u>建立单一接口，不要建立臃肿庞大的接口。</u>

4.2 通过举例说明：美女分隔成几个单一接口，脸蛋好的，身材好的，有气质的。

4.3 接口隔离原则是对接口进行规范约束，其包含4层约束：<br/>
&#160;&#160;&#160;&#160;接口要尽量小（拆分时首先必须满足单一职责原则）<br/>
&#160;&#160;&#160;&#160;接口要高内聚（提高接口的处理能力，减少对外交互）<br/>
&#160;&#160;&#160;&#160;定制服务（只提供访问者需要的方法）<br/>
&#160;&#160;&#160;&#160;接口设计是有限度的（灵活的同时也带来了结构的复杂化）<br/>

4.4 最佳实践<br/>
&#160;&#160;&#160;&#160;一个接口只服务于一个子模块或业务逻辑；<br/>
&#160;&#160;&#160;&#160;通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法；<br/>
&#160;&#160;&#160;&#160;已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；<br/>
&#160;&#160;&#160;&#160;了解环境，拒绝盲从。具体问题具体分析。

### 5.迪米特法则（最少知识原则）
5.1 定义：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道的最少。

5.2 四层含义：<br/>
&#160;&#160;&#160;&#160;1.只和朋友交流（朋友：出现在成员变量、方法的输入输出参数中的类称为成员朋友类。通过老师让体育委员清点女生人数的例子说明，老师的朋友类是GroupLeader，而不是女生类）<br/>
&#160;&#160;&#160;&#160;2.朋友间也是有距离的（尽量不要对外公布太多的public方法和非静态的public变量）<br/>
&#160;&#160;&#160;&#160;3.是自己的就是自己的 <br/>
&#160;&#160;&#160;&#160;4.谨慎使用Serializable <br/>

5.3 最佳实践 <br/>
&#160;&#160;&#160;&#160;适度考虑，过犹不及。如果一个类跳转两次以上才能访问到另一个类，就需要想办法进行重构了。

### 6.开闭原则
6.1 定义：一个软件实体入类、模块和函数应该对扩展开发，对修改关闭。

6.2 三种类型：<br/>
&#160;&#160;&#160;&#160;逻辑变化（只变化一个逻辑，而不涉及其他模块，比如算法的改变）<br/>
&#160;&#160;&#160;&#160;子模块变化（低层次的模块变化必然引起高层次模块的变化）<br/>
&#160;&#160;&#160;&#160;可见视图变化

6.3 为什么要采用开闭原则<br/>
&#160;&#160;&#160;&#160;首先，只要是面向对象编程，在开发时都会提及开闭原则。<br/>
&#160;&#160;&#160;&#160;其次，开闭原则是最基础的一个原则，前面五个原则都是开闭原则的具体形态。<br/>
&#160;&#160;&#160;&#160;最后，开闭原则是非常重要的。<br/>
&#160;&#160;&#160;&#160;1.开闭原则对测试的影响<br/>
&#160;&#160;&#160;&#160;2.开闭原则可以提高复用性<br/>
&#160;&#160;&#160;&#160;3.开闭原则可以提高可维护性<br/>
&#160;&#160;&#160;&#160;4.面向对象开发的要求<br/>










